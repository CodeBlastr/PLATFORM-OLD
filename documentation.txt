testSettings (not done, just the start of a plan for it)
In plugins your models will be the key to set dependencies.  The first note I can think of is... 

### IF the relationship is belongsTo then that means this plugin is dependent on that plugin/model being enabled. ###  
### IF it is any of the other three, then it is for display and should be regulated by settings as to whether the association exists and/or is displayed ###




Creating plugins :::  
- Use utf8_general_ci as the Collation
- Follow database table structure instructions below.
- Code as a normal CakePHP plugin.



Non-heirarchal = Use when a value can have more than one parent.  Ex. catalog item relationships.  1 item can be an upsell, a cross sell, a back end sell, etc. (GOES INTO APP STRUCTURE)

Heirarchal = Use when a value can only have one parent.  Ex. catalog brands.  Mickey Mouse is a brand of the Disney brand, and couldn't have any other parent brands.  (GOES INTO TABLE STRUCTURE)


Made an exception for the app database structure, when it comes to contacts.  There are only two kinds of contacts possible (hard coded) - people and companies.  Because of that, the controller code is what needs to decide who the activities, addresses, details, etc, belong to. (instead of the database dictating who they belong to, as is the case with the rest of the apps)


app/plugin db structure as follows...

 -  root table (ie. app name with an "s")  (ie. catalogs)
 -  any multi value sub items (ie. app name (no s) sub with s) - (ie. catalog_brands, catalog_items)
 DEPRECATED ----  multi-value files table (ie. catalog_brands_medium)
 -  multi-value tags table (ie. catalog_brands_tags)
 DEPRECATED ----  multi-value user groups table (ie. catalog_brand_users) - who can edit this multi-value?



 if non-heirarchal (refer to above)
	 -  multi-value relationships (ie. catalog_items_relationships)
	 -  multi-value relationship types (ie. catalog_item_relationship_types)
 DEPRECATED ----  root files table (ie. catalog_medium)
 -  root tags table (ie. catalog_tags)
 DEPRECATED ----  root user groups table (ie. catalog_user_groups) - who can edit this root?

 if heirarchal (refer to above)
	 -  root relationships (ie. catalog_item_relationship_types)



database table structure standard goes as follow (ORDER IS IMPORTANT, FOR READABILITY AND SCAFFOLDING)...

 -  id (int(11), auto_increment)
 	if heirarchal
	 -  parent_id - (int(11))
        if threaded
         -  lft (int(11))
         -  rght (int(11))
 -  enumerations (ie. type, ie. blog_post_category_id - int(11))
 -  directly related fields (ie. name, title, content, text, email, etc - various dataTypes)
 -  relational_ids (ie. belongsTo : if you're in "blog_posts", you might have a field called "blog_id" here - int(11))
 -  user relationship ids (if you need a user besides the creator to be associated put it here, ie. "assignee_id", "owner_id" - int(11))
 -  creator_id (user id record was created by - auto saved - int(11))
 -  modifier_id (user id record was modified by - auto saved - int(11))
 -  created (date record was created - auto saved - datetime)
 -  modified (date record was modified - auto saved - datetime)


SAVE THIS THINKING JUST IN CAse ###################################
I chose to separate companies and people by database tables, because when I go to create fields, I want them to go straight into the company or people tables.  ie. if I create a company formation field, I want that to be a field in the contacts_companies table.  (This was a very hard choice, because we could have put all contacts into one table, and then just tagged them or typed them as company or people - and though this would be more extensible, it seemed to make the separation between files, activities, and details, etc too much - we'd have had to add like 10 new tables all holding very similar data)
########################## DEPRECATED THINKING END

What if you do everything thats the same in the root, and then everything thats different gets its own table by type.  So contact type people have a table called contact_people and that has "first name", "last name", and contact_companies has just "name", meanwhile they share "lead source", "industry".  And so contact people gets a contact_id and can only have one contact id.  And when you display it, you would show contact people if this contact id has a person assoicated with, and if not then show the company associated with it. <!!!!  THIS WORKED PERFECTLY !!!!!!>


Anything with types should not have tags. Types is a different way of tagging, and you don't need both.  But they should have files, and user groups. 




For every root level type there needs to be a form associated with it. 